<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LMNO</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        @import url("https://fonts.googleapis.com/css?family=Rubik:700&display=swap");

        body {
            font-family: "arial", sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #ffffff;
            padding: 20px;
        }

        #setup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        #gameSetup {
    padding: 20px;
    text-align: center;
        }

        .setup-button {
    margin: 10px;
    padding: 10px 20px;
    font-size: 16px;
    background-color: #fff0f0;
    color: #382b22;
    border: 2px solid #b18597;
    border-radius: 0.5em;
    cursor: pointer;
    transform-style: preserve-3d;
    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), background 150ms cubic-bezier(0, 0, 0.58, 1);
    position: relative;
}

.setup-button::before {
    position: absolute;
    content: "";
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #f9c4d2;
    border-radius: inherit;
    box-shadow: 0 0 0 2px #b18597, 0 0.25em 0 0 #ffe3e2;
    transform: translate3d(0, 0.5em, -1em);
    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), box-shadow 150ms cubic-bezier(0, 0, 0.58, 1);
}

.setup-button:hover {
    background: #ffe9e9;
    transform: translate(0, 0.25em);
}

.setup-button:hover::before {
    box-shadow: 0 0 0 2px #b18597, 0 0.325em 0 0 #ffe3e2;
    transform: translate3d(0, 0.325em, -1em);
}

.setup-button:active {
    background: #ffe9e9;
    transform: translate(0em, 0.5em);
}

.setup-button:active::before {
    box-shadow: 0 0 0 2px #b18597, 0 0 #ffe3e2;
    transform: translate3d(0, 0, -1em);
}

        #gameCodeInput {
            padding: 8px;
            margin: 10px;
            border: 2px solid #b18597;
            border-radius: 5px;
            font-size: 16px;
        }

        .game-board {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 30px;
    padding: 20px;
    z-index: 1;
}

.game-section {
    width: 100%;
    text-align: center;
}

.game-section h3 {
    margin-bottom: 10px;
    color: #2c3e50;
}

.tile-area {
    min-height: 100px;  /* Add this */
    background: #ffffff; /* Add this */
}

        .game-section {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        .tile-area {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            gap: 8px;
            row-gap: 20px;
        }

        .tile {
            width: 40px;
            height: 40px;
            background-color: #e6f2ff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            cursor: pointer;
            border: 1.5px solid #4a90e2;
            border-radius: 0.25em;
            transform-style: preserve-3d;
            transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), background 150ms cubic-bezier(0, 0, 0.58, 1);
            position: relative;
        }

        .tile::before {
            position: absolute;
            content: "";
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #b3d4fc;
            border-radius: 0.15em;
            box-shadow: 0 0 0 1.5px #4a90e2, 0 0.350em 0 0 #d6e9ff;
            transform: translate3d(0, 0.40em, -1em);
            transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), box-shadow 150ms cubic-bezier(0, 0, 0.58, 1);
        }

        .tile:hover {
            background: #d6e9ff;
            transform: translate(0, 0.25em);
        }

        .tile:hover::before {
            box-shadow: 0 0 0 1.5px #4a90e2, 0 0.5em 0 0 #d6e9ff;
            transform: translate3d(0, 0.5em, -1em);
        }

        .tile:active {
            background: #d6e9ff;
            transform: translate(0em, 0.75em);
        }

        .tile:active::before {
            box-shadow: 0 0 0 1.5px #4a90e2, 0 0 #d6e9ff;
            transform: translate3d(0, 0, -1em);
        }

        .tile.revealed {
            background-color: #e0fff0;
            border-color: #81b597;
        }

        .tile.revealed::before {
            background: #c4f9d2;
            box-shadow: 0 0 0 1.5px #81b597, 0 0.325em 0 0 #e2ffe3;
        }

        .tile.inactive {
            background-color: #f0f0f0;
            border-color: #b5b5b5;
            cursor: default;
        }

        .tile.inactive::before {
            background: #d2d2d2;
            box-shadow: 0 0 0 1.5px #b5b5b5, 0 0.350em 0 0 #e6e6e6;
        }
         .tile.revealed.inactive {
            background-color: #e0fff0;  /* Keep the green background */
            border-color: #81b597;      /* Keep the green border */
}

         .tile.revealed.inactive::before {
            background: #c4f9d2;        /* Keep the green shadow */
            box-shadow: 0 0 0 1.5px #81b597, 0 0.325em 0 0 #e2ffe3;
}
@keyframes wiggle {
    0% { transform: rotate(0deg); background-color: #e0fff0; }
    25% { transform: rotate(-5deg); background-color: #ffe9e9; }
    75% { transform: rotate(5deg); background-color: #ffe9e9; }
    100% { transform: rotate(0deg); background-color: #ffe9e9; }
}

.tile.wiggle {
    animation: wiggle 0.5s ease-in-out infinite;
}

.tile.wiggle::before {
    background: #c4f9d2; /* Start with green */
    transition: background-color 0.5s ease;
}

.tile.wiggle.pink::before {
    background: #f9c4d2; /* Transition to pink */
}
@keyframes redWiggle {
    0% { transform: rotate(0deg); background-color: #ffe0e0; }
    25% { transform: rotate(-5deg); background-color: #ffcaca; }
    75% { transform: rotate(5deg); background-color: #ffb5b5; }
    100% { transform: rotate(0deg); background-color: #ffe0e0; }
}

.tile.redWiggle {
    animation: redWiggle 0.5s ease-in-out infinite;
}

.tile.redWiggle::before {
    background: #ffcaca;
}
        .draw-pile .tile {
            background-color: #fff0f0;
            width: 30px;
            height: 30px;
            font-size: 14px;
            border-color: #b18597;
            color: #382b22;
        }

        .draw-pile .tile::before {
            background: #f9c4d2;
            box-shadow: 0 0 0 1.5px #b18597, 0 0.30em 0 0 #ffe3e2;
        }

        .draw-pile .tile:hover {
            background: #ffe9e9;
        }

        .draw-pile .tile:hover::before {
            box-shadow: 0 0 0 1.5px #b18597, 0 0.400em 0 0 #ffe3e2;
            transform: translate3d(0, 0.400em, -1em);
        }

        .draw-pile .tile:active {
            background: #ffe9e9;
            transform: translate(0em, 0.5em);
        }

        .draw-pile .tile:active::before {
            box-shadow: 0 0 0 1.5px #b18597, 0 0 #ffe3e2;
            transform: translate3d(0, 0, -1em);
        }

        .draw-pile .tile.face-up {
            background-color: #fff0f0;
            border-color: #b18597;
        }

        .draw-pile .tile.face-up::before {
            background: #f9c4d2;
            box-shadow: 0 0 0 1.5px #b18597, 0 0.25em 0 0 #ffe3e2;
        }

        .game-over {
            font-size: 24px;
            font-weight: bold;
            color: #e74c3c;
            margin-top: 20px;
        }

        #currentTile {
    margin-top: 20px;
    font-size: 20px;
    font-weight: bold;
    min-height: 24px;  /* Add this to reserve space */
    display: block;    /* Add this */
}


.draw-pile {
    display: grid;
    grid-template-columns: repeat(13, 1fr);
    grid-template-rows: repeat(3, minmax(30px, auto)); /* Define 3 fixed rows */
    grid-auto-rows: 0; /* Any additional rows take no space */
    gap: 8px;
    row-gap: 15px; /* Keep your original row gap */
    max-width: 750px;
    margin: 20px 0;
    min-height: 120px;
}

.game-section:nth-child(2) {
    min-height: 160px;
}

/* Make sure tiles align to the top within the draw pile */
.draw-pile .tile {
    align-self: start;
}

        #discardOption {
            margin-top: 20px;
            font-size: 18px;
        }

        #discardOption button {
            margin: 0 10px;
            padding: 5px 10px;
            font-size: 16px;
            background-color: #fff0f0;
            color: #382b22;
            border: 2px solid #b18597;
            border-radius: 0.5em;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), background 150ms cubic-bezier(0, 0, 0.58, 1);
            position: relative;
        }

        #discardOption button::before {
            position: absolute;
            content: "";
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #f9c4d2;
            border-radius: inherit;
            box-shadow: 0 0 0 2px #b18597, 0 0.25em 0 0 #ffe3e2;
            transform: translate3d(0, 0.5em, -1em);
            transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), box-shadow 150ms cubic-bezier(0, 0, 0.58, 1);
        }

        #discardOption button:hover {
            background: #ffe9e9;
            transform: translate(0, 0.25em);
        }

        #discardOption button:hover::before {
            box-shadow: 0 0 0 2px #b18597, 0 0.325em 0 0 #ffe3e2;
            transform: translate3d(0, 0.325em, -1em);
        }

        #discardOption button:active {
            background: #ffe9e9;
            transform: translate(0em, 0.5em);
        }

        #discardOption button:active::before {
            box-shadow: 0 0 0 2px #b18597, 0 0 #ffe3e2;
            transform: translate3d(0, 0, -1em);
        }
.game-section h3 {
        margin-bottom: 5px !important;  /* Reduce space between label and tiles */
    }
#currentTile, #discardOption {
    visibility: hidden;
    height: 0;
    margin: 0;
    padding: 0;
}

    /* Adjust overall game section spacing */
    .game-section {
        gap: 15px !important;  /* Reduce space between sections */
    }
.game-section:nth-child(3) {   /* This targets the third game section which has Player 2 */
    margin-top: -0px;

}

/* Add new emoji selector styles */
.emoji-code {
    display: flex;
    justify-content: center;
    margin: 20px 0;
    gap: 10px;
}

.emoji {
    font-size: 32px;
    padding: 10px;
    cursor: default;
    background: #fff0f0;
    border-radius: 50%;
    border: 2px solid #b18597;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transition: transform 0.2s;
    box-shadow: 0 3px 5px rgba(0,0,0,0.1);
}

.emoji-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    column-gap: 15px;   /* Keep horizontal spacing reasonable */
    row-gap: 25px;      /* Increase vertical spacing between rows */
    margin: 20px 0;
    padding: 10px;      /* Add some padding around the entire grid */
}

.emoji-button {
    font-size: 32px;
    padding: 10px;
    cursor: pointer;
    background-color: #fff0f0;
    color: #382b22;
    border: 2px solid #b18597;
    border-radius: 50%;
    width: 35px;
    height: 35px;
    display: flex;
    align-items: center;
    justify-content: center;
    user-select: none;
    transform-style: preserve-3d;
    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), background 150ms cubic-bezier(0, 0, 0.58, 1);
    position: relative;
}

.emoji-button::before {
    position: absolute;
    content: "";
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #f9c4d2;
    border-radius: inherit;
    box-shadow: 0 0 0 2px #b18597, 0 0.25em 0 0 #ffe3e2;
    /* Reduce this value to bring the pink shadow closer to the button */
    transform: translate3d(0, 0.25em, -1em); /* Changed from 0.5em to 0.25em */
    transition: transform 150ms cubic-bezier(0, 0, 0.58, 1), box-shadow 150ms cubic-bezier(0, 0, 0.58, 1);
}


.emoji-button:hover {
    background: #ffe9e9;
    transform: translate(0, 0.25em);
}

.emoji-button:hover::before {
    box-shadow: 0 0 0 2px #b18597, 0 0.25em 0 0 #ffe3e2;
    /* Reduce this value as well */
    transform: translate3d(0, 0.15em, -1em); /* Changed from 0.325em to 0.15em */
}

.emoji-button:active {
    background: #ffe9e9;
    transform: translate(0em, 0.5em);
}

.emoji-button:active::before {
    box-shadow: 0 0 0 2px #b18597, 0 0 #ffe3e2;
    transform: translate3d(0, 0, -1em);
}  transform: translate3d(0, 0, -1em);
}

.emoji-button.selected {
    background-color: #e0fff0;
    border-color: #81b597;
}

.emoji-button.selected {
    background-color: #e0fff0;  /* Green background */
    border-color: b18597;      /* Green border */
}

.emoji-selection {
    display: flex;
    flex-direction: row; /* Explicitly set to row */
    justify-content: center;
    align-items: center;
    margin: 10px 0;
    gap: 10px;
    min-height: 70px;
    width: 100%; /* Ensure full width */
}

/* Style for individual emoji slots */
.emoji-slot {
    width: 50px;
    height: 50px;
    border: 2px dashed #b18597;
    border-radius: 50%;
    background: rgba(255,240,240,0.5);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 32px;
    flex: 0 0 auto; /* Prevent shrinking or growing */
}

/* Make the game title more playful */
.game-title {
    font-size: 42px;
    color: #000000;
    text-align: center;
    margin-bottom: 25px;
    font-weight: bold;
}

.setup-message {
    margin: 15px 0;
    font-size: 18px;
    color: #2c3e50;
    text-align: center;
}

@keyframes shake {
    0% { transform: translateX(0); }
    25% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    75% { transform: translateX(-5px); }
    100% { transform: translateX(0); }
}

.shake {
    animation: shake 0.5s ease-in-out;
}


@media screen and (max-width: 480px) {
    .game-board {
        position: fixed;
        width: 100%;
        max-width: 100vw;
        min-height: 100vh;  /* Add this to fill screen height */
        padding: 10px;
        gap: 15px;
        left: 50%;
        transform: translateX(-50%);
        top: 0;
        background: white;  /* Make sure background extends */
    }

    .tile-area {
        grid-template-columns: repeat(9, 1fr) !important;
        gap: 6px !important;     /* Increased from 4px */
        row-gap: 12px !important;  /* Increased from 10px */
    }

    .draw-pile {
        grid-template-columns: repeat(8, 1fr);
        gap: 6px;              /* Increased from 4px */
        row-gap: 12px;         /* Increased from 10px */
    }

    .tile-area .tile,
    .draw-pile .tile {
        width: 30px !important;
        height: 30px !important;
        font-size: 14px !important;
    }

    /* Player switching styles */
    #player2Area {
        display: none;
    }

    #player2Area.active {
        display: grid;
    }

    #player1Area.inactive {
        display: none;
    }

    /* Hide inactive player labels */
    .game-section:has(#player1Area.inactive) > h3,
    .game-section:has(#player2Area:not(.active)) > h3 {
        display: none;
    }

    /* Message visibility */
    #currentTile {
        min-height: 30px;
        position: fixed;
        bottom: 120px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 10px;
        width: 90%;
        text-align: center;
        z-index: 1000;
    }

    #discardOption {
        min-height: 50px;
        position: fixed;
        bottom: 60px;
        left: 50%;
        transform: translateX(-50%);
        background: white;
        padding: 10px;
        width: 90%;
        text-align: center;
        z-index: 1000;
    }
}  }
}
    </style>
</head>
<body>
    <div id="setup-overlay">
    <div id="gameSetup">
        <div class="game-title">LMNO</div>
        
        <!-- Start Game Screen -->
        <div id="startScreen">
            <button id="startButton" class="setup-button">Start New Game</button>
            <button id="joinButton" class="setup-button">Join Game</button>
        </div>
        
        <!-- Create Game Screen (shows emoji code) -->
        <div id="createScreen" style="display: none;">
            <div class="setup-message">Share these emojis with your friend:</div>
            <div class="emoji-code" id="gameCodeEmojis"></div>
            <div id="waitingMessage" class="setup-message">Waiting for other player...</div>
        </div>
        
        <!-- Join Game Screen (emoji selection) -->
        <div id="joinScreen" style="display: none;">
            <div class="setup-message">Pick the 3 emojis to join:</div>
            <div class="emoji-selection" id="emojiSelection">
                <div class="emoji-slot" id="slot1"></div>
                <div class="emoji-slot" id="slot2"></div>
                <div class="emoji-slot" id="slot3"></div>
            </div>
            <div class="emoji-grid" id="emojiGrid"></div>
            <button id="submitJoinButton" class="setup-button">Join Game</button>
            <button id="backButton" class="setup-button">Back</button>
        </div>
    </div>
</div>

    <div class="game-board" id="gameBoard" style="display: none;">
    <div class="game-section">
        <h3>Player 1</h3>
        <div class="tile-area" id="player1Area"></div>
    </div>
    <div class="game-section">
        <div class="draw-pile" id="drawPile"></div>
    </div>
    <div class="game-section">
        <div class="tile-area" id="player2Area"></div>
        <h3>Player 2</h3>
    </div>
    <div id="currentTile"></div>
    <div id="discardOption"></div>
</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.4/socket.io.js"></script>
<script>
// Constants and game state variables
const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
const emojis = ['ðŸ¦Š', 'ðŸ¢', 'ðŸ˜', 'ðŸ¦', 'ðŸ¬', 'ðŸ¦„', 'ðŸ ', 'ðŸ¦‹', 'ðŸµ'];
let gameEmojis = []; // Will store the 3 emojis for the current game
let selectedEmojis = []; // Will store the user's emoji selection
const socket = io('https://lmno-production.up.railway.app/');
console.log('Attempting socket connection...');

// Game state
let gameId = null;
let playerId = null;
let isMyTurn = false;
let currentPlayer = 1;
let gameOver = false;
let currentTile = null;
let discardedLetters = [];  // Track letters that have been discarded
let players = {
    first: null,
    second: null
};

// DOM elements
const setupOverlay = document.getElementById('setup-overlay');
const startButton = document.getElementById('startButton');
const joinButton = document.getElementById('joinButton');
const gameCodeInput = document.getElementById('gameCodeInput');
const playerInfo = document.getElementById('playerInfo');
const waitingMessage = document.getElementById('waitingMessage');
const gameBoard = document.querySelector('.game-board');
const player1Area = document.getElementById('player1Area');
const player2Area = document.getElementById('player2Area');
const drawPile = document.getElementById('drawPile');
const currentTileDisplay = document.getElementById('currentTile');
const discardOption = document.getElementById('discardOption');
const startScreen = document.getElementById('startScreen');
const createScreen = document.getElementById('createScreen');
const joinScreen = document.getElementById('joinScreen');
const submitJoinButton = document.getElementById('submitJoinButton');
const backButton = document.getElementById('backButton');
const gameCodeEmojis = document.getElementById('gameCodeEmojis');
const emojiGrid = document.getElementById('emojiGrid');
const emojiSelection = document.getElementById('emojiSelection');
const emojiSlots = [
    document.getElementById('slot1'),
    document.getElementById('slot2'),
    document.getElementById('slot3')
];

// Socket event handlers
socket.on('connect', () => {
    console.log('Socket Connected!');
});

socket.on('connect_error', (error) => {
    console.log('Connection error:', error);
});
socket.on('syncRequest', (data) => {
    if (data.playerId !== socket.id && gameId === data.gameId) {
        // If I think it's my turn but other player also thinks it's their turn
        if (isMyTurn && data.myTurn) {
            console.log('Turn conflict detected, resolving...');
            // Player 1 gets priority in conflicts
            if (socket.id === players.second) {
                isMyTurn = false;
                console.log('Yielding turn to Player 1');
            }
        }
        
        // Make sure we agree on whose turn it is
        if (currentPlayer !== data.myPlayer) {
            console.log('Player number mismatch, syncing...');
            if (socket.id === players.second) {
                currentPlayer = data.myPlayer === 1 ? 2 : 1;
            }
        }
        
        updateTileColors();
    }
});

socket.on('gameCreated', (data) => {
    console.log('Game created with ID:', data.gameId);
    gameId = data.gameId;
    playerId = data.playerId;
    
    // Direct mapping from A-I to emoji index
    const emojiMap = {
        'A': 0, 'B': 1, 'C': 2, 
        'D': 3, 'E': 4, 'F': 5,
        'G': 6, 'H': 7, 'I': 8
    };
    
    // Convert the gameId to emojis using direct mapping
    const gameIdChars = gameId.split('');
    gameEmojis = gameIdChars.map(char => {
        const index = emojiMap[char];
        console.log(`Converting ${char} to emoji index ${index}: ${emojis[index]}`);
        return emojis[index];
    });
    
    // Display the emojis
    displayGameEmojis(gameEmojis);
    
    // Switch to create screen
    startScreen.style.display = 'none';
    createScreen.style.display = 'block';
});

socket.on('gameStarted', (data) => {
    gameId = data.gameId;
    playerId = socket.id;
    players.first = data.players[0];
    players.second = data.players[1];
    setupOverlay.style.display = 'none';
    gameBoard.style.display = 'flex';
    isMyTurn = data.players[0] === socket.id;
    currentPlayer = 1;
    initGame();
    updateTileColors();
});

socket.on('gameMove', (data) => {
    console.log('Move received:', data);
    if (data.type === 'discardOffer') {
    if (data.playerId !== socket.id) {
        const tiles = Array.from(drawPile.children);
        
        // Clear any existing text and animations
        tiles.forEach(tile => {
            if (!tile.classList.contains('wiggle')) {
                tile.textContent = '';
            }
            tile.classList.remove('wiggle', 'pink', 'duplicate-offer');
        });
        
        // IMPROVED TILE FINDING: Look for tile by letter
        let matchingTile = tiles.find(tile => tile.dataset.letter === data.tile);
        
        // If no matching tile found, create one at the end of the draw pile
        if (!matchingTile) {
            console.log('No matching tile found for letter:', data.tile, 'creating one');
            matchingTile = document.createElement('div');
            matchingTile.classList.add('tile');
            matchingTile.dataset.letter = data.tile;
            matchingTile.addEventListener('click', selectDrawTile);
            drawPile.appendChild(matchingTile);
        }
        
        // Apply animation classes
        matchingTile.classList.add('wiggle', 'duplicate-offer');
        matchingTile.textContent = data.tile;
        
        // Hide text on all other matching tiles
        tiles.forEach(tile => {
            if (tile !== matchingTile && tile.dataset.letter === data.tile) {
                tile.textContent = '';
            }
        });
        
        // Disable clicking on other tiles
        tiles.forEach(tile => {
            if (tile !== matchingTile) {
                tile.style.pointerEvents = 'none';
            }
        });
        
        setTimeout(() => {
            matchingTile.classList.add('pink');
        }, 250);

        matchingTile.addEventListener('click', () => {
            // Re-enable clicking on all tiles after this one is played
            tiles.forEach(tile => {
                tile.style.pointerEvents = 'auto';
            });
            const duplicateTiles = drawPile.querySelectorAll('.duplicate-offer');
            duplicateTiles.forEach(tile => tile.remove());
        }, { once: true });
        
        isMyTurn = true;
        currentPlayer = data.currentPlayer;
        updateTileColors();
    }
}
    if (data.type === 'gameOver') {
    gameOver = true;
    
    if (data.winner === 'tie') {
        // For a tie, show message in both player labels
        const player1Label = document.querySelector('.game-section:nth-child(1) h3');
        const player2Label = document.querySelector('.game-section:nth-child(3) h3');
        player1Label.textContent = "Player 1: It's a Tie!";
        player2Label.textContent = "Player 2: It's a Tie!";
    } else {
        // Update the labels based on who won
        const winnerNum = parseInt(data.winner);
        const player1Label = document.querySelector('.game-section:nth-child(1) h3');
        const player2Label = document.querySelector('.game-section:nth-child(3) h3');
        
        if (winnerNum === 1) {
            player1Label.textContent = "Player 1: Winner!";
            player2Label.textContent = "Player 2: Player 1 Wins!";
        } else {
            player1Label.textContent = "Player 1: Player 2 Wins!";
            player2Label.textContent = "Player 2: Winner!";
        }
    }
    
    isMyTurn = false;
    updateTileColors();
    }
    else if (data.playerId !== socket.id) {
        console.log('Processing opponent move:', data.type);
        
        if (data.type === 'specialTile') {
    if (data.action === 'skip') {
    currentTileDisplay.textContent = "Opponent used Skip tile!";
    
    // Add message to receiving player's label
    const nextPlayer = data.currentPlayer === 1 ? 2 : 1;
    const playerLabel = document.querySelector(`.game-section:nth-child(${nextPlayer === 1 ? 1 : 3}) h3`);
    playerLabel.textContent = `Player ${nextPlayer}: Skipped!`;
    
    const tiles = Array.from(drawPile.children);
    const skipTile = tiles[data.tilePosition];
    if (skipTile) {
        skipTile.classList.add('selected');
        skipTile.textContent = '>>';
        
        setTimeout(() => {
            skipTile.remove();
            currentTileDisplay.textContent = '';
            playerLabel.textContent = `Player ${nextPlayer}`;  // Reset label
            currentTile = null;
            isMyTurn = true;
            currentPlayer = nextPlayer;
            updateTileColors();
        }, 3000);
        }
    } else if (data.action === 'reverse') {
    currentTileDisplay.textContent = "Opponent used Reverse tile!";
    
    // For receiving player, use currentPlayer directly since it's already correct
    const playerLabel = document.querySelector(`.game-section:nth-child(${currentPlayer === 1 ? 1 : 3}) h3`);
    playerLabel.textContent = `Player ${currentPlayer}: Reversed!`;
    
    const tiles = Array.from(drawPile.children);
    const reverseTile = tiles[data.tilePosition];
    if (reverseTile) {
        reverseTile.classList.add('selected');
        reverseTile.textContent = '@';
        
        setTimeout(() => {
            reverseTile.remove();
            currentTileDisplay.textContent = '';
            playerLabel.textContent = `Player ${currentPlayer}`;  // Reset label
            currentTile = null;
            
            // Ensure switch happens at same time
            switchPiles();
            isMyTurn = true;
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTileColors();
        }, 3000);
        }
else if (data.type === 'cleanupTiles') {
  if (data.playerId !== socket.id) {
    console.log('Received cleanup request for letters:', data.removedLetters);
    
    data.removedLetters.forEach(letter => {
      // Add to tracking array
      if (!discardedLetters.includes(letter)) {
        discardedLetters.push(letter);
      }
      
      // Remove tiles
      const tilesToRemove = Array.from(drawPile.children).filter(tile => 
        tile.dataset.letter === letter
      );
      tilesToRemove.forEach(tile => tile.remove());
    });
  }
}

            } else if (data.action === 'bothHave') {
    if (data.playerId !== socket.id) {
        // Process SILENTLY - no messages
        
        // Clean up any selected tile
        const selectedTile = drawPile.querySelector('.tile.selected');
        if (selectedTile) selectedTile.remove();
        
        // Remove discarded letter tiles
        if (data.discardedLetter) {
            if (!discardedLetters.includes(data.discardedLetter)) {
                discardedLetters.push(data.discardedLetter);
            }
            
            const allSameTiles = Array.from(drawPile.children).filter(tile => 
                tile.dataset.letter === data.discardedLetter
            );
            allSameTiles.forEach(tile => tile.remove());
        }
        
        // Update game state silently
        setTimeout(() => {
            currentTile = null;
            isMyTurn = true;
            currentPlayer = data.currentPlayer === 1 ? 2 : 1;
            updateTileColors();
        }, 1000);
    }
}
// Handle the new reserve tile event in socket handler
// Add this to your socket.on('gameMove') handler:
if (data.type === 'addReserveTile') {
    if (data.playerId !== socket.id) {
        // Add the reserve tile to my draw pile too
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.dataset.letter = data.letter;
        tile.addEventListener('click', selectDrawTile);
        drawPile.appendChild(tile);
    }
}
else if (data.type === 'pileSwitch') {
    if (data.playerId !== socket.id) {
        console.log('Received pile switch sync');
        
        // Force synchronization of both player areas
        const player1NewState = data.player2State; // Reversed on purpose
        const player2NewState = data.player1State; // Reversed on purpose
        
        // Clear and rebuild player 1 area
        player1Area.innerHTML = '';
        player1NewState.forEach(tileData => {
            const newTile = document.createElement('div');
            newTile.classList.add('tile');
            if (tileData.revealed) newTile.classList.add('revealed');
            newTile.dataset.letter = tileData.letter;
            if (tileData.wildValue) newTile.dataset.wildValue = tileData.wildValue;
            newTile.textContent = tileData.revealed ? (tileData.wildValue || tileData.letter) : '';
            newTile.addEventListener('click', placeTile);
            player1Area.appendChild(newTile);
        });
        
        // Clear and rebuild player 2 area
        player2Area.innerHTML = '';
        player2NewState.forEach(tileData => {
            const newTile = document.createElement('div');
            newTile.classList.add('tile');
            if (tileData.revealed) newTile.classList.add('revealed');
            newTile.dataset.letter = tileData.letter;
            if (tileData.wildValue) newTile.dataset.wildValue = tileData.wildValue;
            newTile.textContent = tileData.revealed ? (tileData.wildValue || tileData.letter) : '';
            newTile.addEventListener('click', placeTile);
            player2Area.appendChild(newTile);
        });
        
        updateTileColors();
    }
}
        } else if (data.type === 'selectTile') {
    const tiles = Array.from(drawPile.children);
    // Use the position from the data instead of finding first unselected tile
    const tileToSelect = tiles[data.tilePosition];
    if (tileToSelect) {
        tiles.forEach(tile => {
            tile.classList.remove('selected');
            tile.textContent = '';
        });
        tileToSelect.classList.add('selected');
        tileToSelect.textContent = data.tile;
        currentTile = data.tile;
        currentTileDisplay.textContent = ``;
    }
        } else if (data.type === 'placeTile') {
            const playerArea = socket.id === players.first ? player2Area : player1Area;
            const tile = playerArea.children[data.position];
            if (tile) {
                const replacedLetter = tile.dataset.letter;
                
                tile.dataset.letter = data.tile;
                tile.textContent = data.tile;
                tile.classList.add('revealed');
                
                const selectedTile = drawPile.querySelector('.tile.selected');
                if (selectedTile) selectedTile.remove();

                if (replacedLetter) {
                    returnTileToDrawPile(replacedLetter);
                }
            }
            isMyTurn = false;
            updateTileColors();
        }
    }
});
// Button event listeners
startButton.addEventListener('click', () => {
    console.log('Start button clicked');
    socket.emit('createGame');
    startButton.disabled = true;
    joinButton.disabled = true;
});

function handleJoinAction(event) {
    event.preventDefault(); // Prevent any default behavior
    if (gameCodeInput.style.display === 'none') {
        gameCodeInput.style.display = 'block';
        joinButton.textContent = 'Submit';
    } else {
        const code = gameCodeInput.value.trim().toUpperCase();
        if (code) {
            console.log('Attempting to join game:', code);
            socket.emit('joinGame', code);
        }
    }
}

// Add both click and touch events for join button
joinButton.addEventListener('click', () => {
    startScreen.style.display = 'none';
    joinScreen.style.display = 'block';
    createEmojiGrid();
});

backButton.addEventListener('click', () => {
    joinScreen.style.display = 'none';
    startScreen.style.display = 'block';
    // Reset selections
    selectedEmojis = [];
    updateEmojiSelection();
});

submitJoinButton.addEventListener('click', () => {
    // Check if 3 emojis are selected
    if (selectedEmojis.length === 3) {
        // Direct mapping from emoji index to character
        const charMap = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
        
        // Convert emojis to a string code using consistent mapping
        const code = selectedEmojis.map(emoji => {
            const index = emojis.indexOf(emoji);
            const char = charMap[index];
            console.log(`Converting emoji ${emoji} (index ${index}) to char ${char}`);
            return char;
        }).join('');
        
        console.log('Attempting to join game with emoji code:', code);
        socket.emit('joinGame', code);
    } else {
        // Visual feedback that we need 3 emojis
        emojiSelection.classList.add('shake');
        setTimeout(() => {
            emojiSelection.classList.remove('shake');
        }, 500);
    }
});

function handleJoinAction(event) {
    event.preventDefault(); // Prevent any default behavior
    if (gameCodeInput.style.display === 'none') {
        gameCodeInput.style.display = 'block';
        joinButton.textContent = 'Submit';
    } else {
        const code = gameCodeInput.value.trim().toUpperCase();
        if (code) {
            console.log('Attempting to join game:', code);
            socket.emit('joinGame', code);
        }
    }
}


// Game functions
function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}
function syncGameState() {
    if (gameId && playerId) {
        // Get count of remaining tiles
        const remainingTiles = drawPile.children.length;
        
        socket.emit('syncRequest', {
            gameId: gameId,
            myTurn: isMyTurn,
            myPlayer: currentPlayer,
            remainingTiles: remainingTiles,
            timestamp: Date.now()
        });
        
        // Increase sync frequency when few tiles remain
        if (remainingTiles < 10 && syncInterval._idleTimeout > 2000) {
            clearInterval(syncInterval);
            syncInterval = setInterval(syncGameState, 2000); // More frequent checks
        }
    }
}
    // Add this function to periodically check and sync draw pile state
function syncDrawPile() {
    if (gameId && drawPile.children.length < 10) {
        // Only sync when few tiles remain
        const tilePositions = Array.from(drawPile.children).map(tile => ({
            letter: tile.dataset.letter,
            position: Array.from(drawPile.children).indexOf(tile)
        }));
        
        socket.emit('syncDrawPile', {
            gameId: gameId,
            tiles: tilePositions,
            currentPlayer: currentPlayer,
            isMyTurn: isMyTurn
        });
    }
}

// Run every 2 seconds when getting low on tiles
const drawPileInterval = setInterval(syncDrawPile, 2000);

// Add this handler to your socket.on section
socket.on('syncDrawPile', (data) => {
    if (data.gameId === gameId && data.playerId !== socket.id) {
        // Make sure turns are in sync
        if (currentPlayer !== data.currentPlayer) {
            console.log('Syncing current player:', data.currentPlayer);
            currentPlayer = data.currentPlayer;
            isMyTurn = socket.id === (currentPlayer === 1 ? players.first : players.second);
            updateTileColors();
        }
    }
});

// Start with normal interval
let syncInterval = setInterval(syncGameState, 5000);
function createTiles(container, count, isDrawPile = false) {
    let letters = [];
    if (isDrawPile) {
        // Track special tile counts
        let skipCount = 0, reverseCount = 0, wildCount = 0;
        
        const visibleLetters = alphabet.repeat(2).split('');
        const specialTiles = Array(4).fill('>>').concat(Array(4).fill('@'), Array(4).fill('?'));
        letters = shuffleArray([...visibleLetters, ...specialTiles]);
        
        // Ensure we don't exceed special tile limits
        letters = letters.filter(letter => {
            if (letter === '>>') return skipCount++ < 4;
            if (letter === '@') return reverseCount++ < 4;
            if (letter === '?') return wildCount++ < 4;
            return true;
        }).slice(0, count);
        
        window.reserveTiles = alphabet.split('');
    } else {
        // Player areas stay exactly the same
        const alphabetTiles = alphabet.split('');
        const specialTiles = Array(1).fill('>>').concat(Array(1).fill('@'), Array(1).fill('?'));
        letters = shuffleArray([...alphabetTiles, ...specialTiles]).slice(0, count);
    }
    
    for (let i = 0; i < letters.length; i++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.dataset.letter = letters[i];
        if (isDrawPile) {
            tile.addEventListener('click', selectDrawTile);
        } else {
            tile.addEventListener('click', placeTile);
        }
        container.appendChild(tile);
    }
}

// Add function to add reserve tiles when needed
function addReserveTileIfNeeded() {
    // Skip if no reserve or game over
    if (!window.reserveTiles || window.reserveTiles.length === 0 || gameOver) return;
    
    // Calculate how many more tiles are needed
    const p1Unrevealed = Array.from(player1Area.children).filter(t => !t.classList.contains('revealed')).length;
    const p2Unrevealed = Array.from(player2Area.children).filter(t => !t.classList.contains('revealed')).length;
    const maxUnrevealed = Math.max(p1Unrevealed, p2Unrevealed);
    const drawPileCount = drawPile.children.length;
    
    // Check if we need to add a reserve tile
    if (drawPileCount < maxUnrevealed) {
        // Draw pile too low, add ONE reserve tile at a time (to keep it subtle)
        if (window.reserveTiles.length > 0) {
            // Get next reserve tile
            const letter = window.reserveTiles.pop();
            
            // Skip if this letter is already discarded
            if (discardedLetters.includes(letter)) {
                // Try again with next tile
                setTimeout(addReserveTileIfNeeded, 100);
                return;
            }
            
            // Add one new tile to draw pile
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.dataset.letter = letter;
            tile.addEventListener('click', selectDrawTile);
            drawPile.appendChild(tile);
            
            // Sync with other player
            socket.emit('makeMove', {
                type: 'addReserveTile',
                gameId: gameId,
                playerId: socket.id,
                letter: letter,
                timestamp: Date.now()
            });
        }
    }
}

// Add this with your other game state variables
const letterCounts = {};


function cleanupDuplicateTiles() {
    if (!gameId || !playerId || gameOver) return;
    
    // Calculate minimum needed tiles
    const p1Unrevealed = Array.from(player1Area.children).filter(t => !t.classList.contains('revealed')).length;
    const p2Unrevealed = Array.from(player2Area.children).filter(t => !t.classList.contains('revealed')).length;
    const maxUnrevealed = Math.max(p1Unrevealed, p2Unrevealed);
    
    // Check every letter
    for (const letter of alphabet.split('')) {
        // If both players have this letter
        if (bothPlayersHaveTile(letter)) {
            // Remove all instances of this letter from draw pile
            const tilesToRemove = Array.from(drawPile.children).filter(tile => 
                tile.dataset.letter === letter
            );
            
            if (tilesToRemove.length > 0) {
                // Track discarded letter
                if (!discardedLetters.includes(letter)) {
                    discardedLetters.push(letter);
                }
                
                // Remove the tiles
                tilesToRemove.forEach(tile => tile.remove());
                
                // Notify other player
                socket.emit('makeMove', {
                    type: 'cleanupTiles',
                    gameId: gameId,
                    playerId: socket.id,
                    removedLetters: [letter],
                    timestamp: Date.now()
                });
            }
        }
    }
    
    // After cleanup, check if we need more tiles
    if (drawPile.children.length < maxUnrevealed + 5) {
        addReserveTileIfNeeded();
    }
}



// Add a function to count all tiles in the game
function countAllTiles() {
    // Reset counts
    Object.keys(letterCounts).forEach(key => {
        letterCounts[key] = 0;
    });
    
    // Count player 1 tiles
    Array.from(player1Area.children).forEach(tile => {
        const letter = tile.dataset.letter;
        if (letter) letterCounts[letter] = (letterCounts[letter] || 0) + 1;
    });
    
    // Count player 2 tiles
    Array.from(player2Area.children).forEach(tile => {
        const letter = tile.dataset.letter;
        if (letter) letterCounts[letter] = (letterCounts[letter] || 0) + 1;
    });
    
    // Count draw pile tiles
    Array.from(drawPile.children).forEach(tile => {
        const letter = tile.dataset.letter;
        if (letter) letterCounts[letter] = (letterCounts[letter] || 0) + 1;
    });
    
    // Log for debugging
    console.log('Current letter counts:', {...letterCounts});
}
function playerHasLetter(player, letter) {
    const area = player === 1 ? player1Area : player2Area;
    return Array.from(area.children).some(tile => {
        if (!tile.classList.contains('revealed')) return false;
        
        // If it's a wild tile, check if it was placed in a position 
        // corresponding to this letter, not what letter it represents
        if (tile.dataset.letter === '?') {
            // Only count if the wild tile is actually representing this letter
            const position = Array.from(area.children).indexOf(tile);
            const actualLetter = alphabet[position];
            return actualLetter === letter;
        }
        
        // Regular tile check
        return tile.dataset.letter === letter;
    });
}
// Updated function that completely removes all "both have" messages
function bothPlayersHaveTile(letter) {
    // Skip special tiles
    if (letter === '>>' || letter === '@' || letter === '?') {
        return false;
    }
    
    // Check if player 1 has the letter revealed
    const p1Has = Array.from(player1Area.children).some(tile => {
        if (!tile.classList.contains('revealed')) return false;
        
        // Direct match for regular tiles
        if (tile.dataset.letter === letter) return true;
        
        // For wild tiles, check position
        if (tile.dataset.letter === '?') {
            const position = Array.from(player1Area.children).indexOf(tile);
            if (position >= 0 && position < alphabet.length) {
                return alphabet[position] === letter;
            }
        }
        return false;
    });
    
    // Check if player 2 has the letter revealed
    const p2Has = Array.from(player2Area.children).some(tile => {
        if (!tile.classList.contains('revealed')) return false;
        
        // Direct match for regular tiles
        if (tile.dataset.letter === letter) return true;
        
        // For wild tiles, check position
        if (tile.dataset.letter === '?') {
            const position = Array.from(player2Area.children).indexOf(tile);
            if (position >= 0 && position < alphabet.length) {
                return alphabet[position] === letter;
            }
        }
        return false;
    });
    
    // Return result without any console logs or messages
    return p1Has && p2Has;
}

// Function to clear any "both have" messages that might appear
function clearBothHaveMessages() {
    // Clear currentTileDisplay if it has "both have" message
    if (currentTileDisplay && 
        currentTileDisplay.textContent && 
        currentTileDisplay.textContent.toLowerCase().includes('both')) {
        currentTileDisplay.textContent = '';
    }
    
    // Clear player labels if they have "both have" messages
    const allLabels = document.querySelectorAll('.game-section h3');
    allLabels.forEach(label => {
        if (label.textContent && 
            label.textContent.toLowerCase().includes('both have')) {
            // Keep just the player part
            const playerPart = label.textContent.split(':')[0].trim();
            if (playerPart) {
                label.textContent = playerPart;
            }
        }
    });
}

// Run this frequently
setInterval(clearBothHaveMessages, 100);



function removeTileFromDrawPile(letter) {
    const tilesToRemove = Array.from(drawPile.children).filter(tile => 
        tile.dataset.letter === letter
    );
    tilesToRemove.forEach(tile => tile.remove());
}

function handleSkipTile(selectedTile) {
    currentTileDisplay.textContent = "Skip tile!";
    
    // Add message to player label
    const activePlayer = currentPlayer;  // Store current player before it changes
    const playerLabel = document.querySelector(`.game-section:nth-child(${activePlayer === 1 ? 1 : 3}) h3`);
    playerLabel.textContent = `Player ${activePlayer}: Skip!`;
    
    selectedTile.classList.add('selected');
    selectedTile.textContent = '>>';
    
    const tilePosition = Array.from(drawPile.children).indexOf(selectedTile);
    const nextPlayer = currentPlayer === 1 ? 2 : 1;
    
    sendMove({
    type: 'specialTile',
    tile: '>>',
    action: 'skip',
    tilePosition: tilePosition
});
    
    setTimeout(() => {
        selectedTile.remove();
        currentTileDisplay.textContent = '';
        playerLabel.textContent = `Player ${activePlayer}`;  // Reset label
        currentTile = null;
        isMyTurn = false;
        currentPlayer = nextPlayer;
        updateTileColors();
    }, 3000);
}

function handleReverseTile(selectedTile) {
    currentTileDisplay.textContent = "Reverse tile!";
    
    // Add message to player label
    const activePlayer = currentPlayer;  // Store current player before it changes
    const playerLabel = document.querySelector(`.game-section:nth-child(${activePlayer === 1 ? 1 : 3}) h3`);
    playerLabel.textContent = `Player ${activePlayer}: Reverse!`;
    
    selectedTile.classList.add('selected');
    selectedTile.textContent = '@';
    
    const tilePosition = Array.from(drawPile.children).indexOf(selectedTile);
    
    socket.emit('makeMove', {
        type: 'specialTile',
        tile: '@',
        action: 'reverse',
        tilePosition: tilePosition,
        currentPlayer: currentPlayer,  // Track current player
        gameId: gameId,
        playerId: socket.id
    });
    
    setTimeout(() => {
        selectedTile.remove();
        currentTileDisplay.textContent = '';
        playerLabel.textContent = `Player ${activePlayer}`;  // Reset label using stored player
        currentTile = null;
        
        switchPiles();
        isMyTurn = false;
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        updateTileColors();
    }, 3000);
}

function selectDrawTile(event) {
    if (!isMyTurn || gameOver || currentTile) {
        console.log('Cannot select tile - blocked by:', {
            turnBlocked: !isMyTurn,
            gameOverBlocked: gameOver,
            currentTileBlocked: currentTile
        });
        return;
    }
    
    const selectedTile = event.target;
    const tilePosition = Array.from(drawPile.children).indexOf(selectedTile);
    currentTile = selectedTile.dataset.letter;
    console.log('Selected tile:', currentTile);

    // Handle special tiles first
    if (currentTile === '>>') {
        handleSkipTile(selectedTile);
        return;
    }
    if (currentTile === '@') {
        handleReverseTile(selectedTile);
        return;
    }

    // Normal tile selection logic
    drawPile.querySelectorAll('.tile').forEach(tile => {
        tile.classList.remove('selected');
        if (tile === selectedTile) {
            tile.textContent = currentTile;
        } else {
            tile.textContent = '';
        }
    });
    
    selectedTile.classList.add('selected');
    selectedTile.textContent = currentTile;
    currentTileDisplay.textContent = '';
    
    socket.emit('makeMove', {
        type: 'selectTile',
        tile: currentTile,
        tilePosition: tilePosition,
        gameId: gameId,
        playerId: socket.id
    });
    
    // Check for duplicate in player's own board
if (currentTile !== '?' && playerHasLetter(currentPlayer, currentTile)) {
    // First check if both players have this tile
    if (bothPlayersHaveTile(currentTile)) {
        // Silently clean up the tile without animation
        selectedTile.remove();
        if (!discardedLetters.includes(currentTile)) {
            discardedLetters.push(currentTile);
        }
        // Let player select another tile
        currentTile = null;
        return;
    }
    
    // Only do wiggle animation if not both have
    selectedTile.classList.add('redWiggle', 'duplicate-offer');
        
        socket.emit('makeMove', {
            type: 'discardOffer',
            gameId: gameId,
            tile: currentTile,
            currentPlayer: currentPlayer === 1 ? 2 : 1,
            playerId: socket.id,
            tilePosition: tilePosition
        });
        
        setTimeout(() => {
            const duplicateTile = drawPile.querySelector('.duplicate-offer');
            if (duplicateTile) {
                duplicateTile.remove();
            }
            currentTile = null;
            isMyTurn = false;
            currentPlayer = currentPlayer === 1 ? 2 : 1;
            updateTileColors();
        }, 3000);
        
        return;
    }
}
function offerDiscardToOtherPlayer(selectedTile) {
    // First set my tiles to inactive
    isMyTurn = false;
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTileColors();
    
    socket.emit('makeMove', {
        type: 'discardOffer',
        gameId: gameId,
        tile: currentTile,
        currentPlayer: currentPlayer,
        playerId: socket.id
    });
    
    discardOption.innerHTML = 'Waiting for other player\'s decision...';
}


function returnTileToDrawPile(letter, faceUp = false) {
    // Count tiles first
    countAllTiles();
    
    // Check if we already have 4 of this letter
    if (letterCounts[letter] >= 4) {
        console.log(`Already have ${letterCounts[letter]} of letter ${letter}, not adding more`);
        return;
    }
    
    const newTile = document.createElement('div');
    newTile.classList.add('tile');
    newTile.dataset.letter = letter;
    newTile.addEventListener('click', selectDrawTile);
    
    if (faceUp) {
        newTile.classList.add('face-up');
        newTile.textContent = letter;
    }

    drawPile.appendChild(newTile);
    
    // Update count
    letterCounts[letter] = (letterCounts[letter] || 0) + 1;
}

function placeTile(event) {
    console.log('Attempting to place tile - isMyTurn:', isMyTurn);
    if (!isMyTurn || gameOver || !currentTile) return;
    const currentPlayerArea = currentPlayer === 1 ? player1Area : player2Area;
    if (event.target.parentNode !== currentPlayerArea) return;
    const position = Array.from(currentPlayerArea.children).indexOf(event.target);
    if (currentTile !== '?' && alphabet[position] !== currentTile && currentTile !== '>>' && currentTile !== '@') return;
    if (event.target.classList.contains('revealed')) return;

    const replacedLetter = event.target.dataset.letter;

    // Find and remove the animated tile from draw pile
    const animatedTile = drawPile.querySelector('.wiggle');
    if (animatedTile) {
        animatedTile.remove();
    }
    
    socket.emit('makeMove', {
        type: 'placeTile',
        tile: currentTile,
        position: position,
        gameId: gameId,
        replacedTile: replacedLetter
    });

    // Place the new tile
event.target.dataset.letter = currentTile;
event.target.textContent = currentTile;
event.target.classList.add('revealed');

// Add a brief "pop" animation to the placed tile
event.target.animate([
    { transform: 'scale(1)' },
    { transform: 'scale(1.2)' },
    { transform: 'scale(1)' }
], {
    duration: 300,
    easing: 'ease-out'
});

// Remove selected tile from draw pile
const selectedTile = drawPile.querySelector('.tile.selected');
if (selectedTile) selectedTile.remove();
    // Return replaced tiles to draw pile
    if (replacedLetter) {
        returnTileToDrawPile(replacedLetter);
    }

    currentTile = null;
    currentTileDisplay.textContent = '';
    
    // IMMEDIATELY run cleanup to remove any now-shared letters
    cleanupDuplicateTiles();
    
    updateTileColors();
    checkGameEnd(currentPlayerArea);
}

function sendMove(moveData) {
  // Ensure these properties are included in every move
  const baseData = {
    gameId: gameId,
    playerId: socket.id,
    currentPlayer: currentPlayer,
    nextPlayer: currentPlayer === 1 ? 2 : 1,  // Always calculate next player
    timestamp: Date.now()
  };
  
  // Merge with specific move data
  socket.emit('makeMove', {...baseData, ...moveData});
}



function handleSkipMove(data) {
    currentTileDisplay.textContent = "Opponent used Skip tile!";
    const tiles = Array.from(drawPile.children);
    const skipTile = tiles.find(tile => tile.dataset.letter === '>>');
    if (skipTile) {
        skipTile.remove();
    }
    
    setTimeout(() => {
        currentTileDisplay.textContent = '';
        currentTile = null;
        isMyTurn = true;
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        updateTileColors();
    }, 3000);
}

function handleReverseMove(data) {
    currentTileDisplay.textContent = "Opponent used Reverse tile!";
    const tiles = Array.from(drawPile.children);
    const reverseTile = tiles.find(tile => tile.dataset.letter === '@');
    if (reverseTile) {
        reverseTile.remove();
    }
    
    setTimeout(() => {
        switchPiles();
        currentTileDisplay.textContent = '';
        currentTile = null;
        isMyTurn = true;
        currentPlayer = currentPlayer === 1 ? 2 : 1;
        updateTileColors();
    }, 3000);
}

function switchPiles() {
    // Store current state before clearing
    const player1Tiles = Array.from(player1Area.children).map(tile => ({
        letter: tile.dataset.letter,
        revealed: tile.classList.contains('revealed'),
        wildValue: tile.dataset.wildValue || null
    }));
    
    const player2Tiles = Array.from(player2Area.children).map(tile => ({
        letter: tile.dataset.letter,
        revealed: tile.classList.contains('revealed'),
        wildValue: tile.dataset.wildValue || null
    }));

    // Clear both areas
    player1Area.innerHTML = '';
    player2Area.innerHTML = '';

    // Rebuild areas with stored state
    player2Tiles.forEach(tileData => {
        const newTile = document.createElement('div');
        newTile.classList.add('tile');
        if (tileData.revealed) newTile.classList.add('revealed');
        newTile.dataset.letter = tileData.letter;
        if (tileData.wildValue) newTile.dataset.wildValue = tileData.wildValue;
        newTile.textContent = tileData.revealed ? (tileData.wildValue || tileData.letter) : '';
        newTile.addEventListener('click', placeTile);
        player1Area.appendChild(newTile);
    });
    
    player1Tiles.forEach(tileData => {
        const newTile = document.createElement('div');
        newTile.classList.add('tile');
        if (tileData.revealed) newTile.classList.add('revealed');
        newTile.dataset.letter = tileData.letter;
        if (tileData.wildValue) newTile.dataset.wildValue = tileData.wildValue;
        newTile.textContent = tileData.revealed ? (tileData.wildValue || tileData.letter) : '';
        newTile.addEventListener('click', placeTile);
        player2Area.appendChild(newTile);
    });

    // Send a specific sync event after pile switch
    sendMove({
        type: 'pileSwitch',
        player1State: player1Tiles,
        player2State: player2Tiles
    });

    updateTileColors(); // Add this call
}
function checkGameEnd(playerArea) {
    // Check if all tiles in player area are revealed
    if (Array.from(playerArea.children).every(tile => tile.classList.contains('revealed'))) {
        gameOver = true;
        
        // Find player number based on area
        const winningPlayer = playerArea === player1Area ? 1 : 2;
        
        // Update both player labels
        const player1Label = document.querySelector('.game-section:nth-child(1) h3');
        const player2Label = document.querySelector('.game-section:nth-child(3) h3');
        
        if (winningPlayer === 1) {
            player1Label.textContent = "Player 1: Winner!";
            player2Label.textContent = "Player 2: Player 1 Wins!";
        } else {
            player1Label.textContent = "Player 1: Player 2 Wins!";
            player2Label.textContent = "Player 2: Winner!";
        }
        
        // Send game over to other player
        socket.emit('makeMove', {
            type: 'gameOver',
            gameId: gameId,
            winner: winningPlayer,
            timestamp: Date.now()
        });
        
        isMyTurn = false;
        updateTileColors();
        return true;
    }
    
    // Check for tie (no more moves possible)
    if (drawPile.children.length === 0) {
        gameOver = true;
        
        // Update both player labels for tie
        const player1Label = document.querySelector('.game-section:nth-child(1) h3');
        const player2Label = document.querySelector('.game-section:nth-child(3) h3');
        player1Label.textContent = "Player 1: It's a Tie!";
        player2Label.textContent = "Player 2: It's a Tie!";
        
        socket.emit('makeMove', {
            type: 'gameOver',
            gameId: gameId,
            winner: 'tie',
            timestamp: Date.now()
        });
        
        isMyTurn = false;
        updateTileColors();
        return true;
    }
    
    return false;
    }

function checkWinCondition(area) {
    return Array.from(area.children).every(tile => 
        tile.classList.contains('revealed')
    );
}

function canMakeMove() {
    return drawPile.children.length > 0;
}

function updateTileColors() {
    // Get ALL tiles, not just unrevealed ones
    const player1Tiles = player1Area.querySelectorAll('.tile');
    const player2Tiles = player2Area.querySelectorAll('.tile');
    
    if (currentPlayer === 1) {
        if (socket.id === players.first) {
            // First player's browser
            player1Tiles.forEach(tile => {
                tile.classList.remove('inactive');
                // Only show text content if revealed
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player2Tiles.forEach(tile => {
                tile.classList.add('inactive');
                // Only show text content if revealed
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player1Area.classList.remove('inactive');
            player2Area.classList.remove('active');
        } else {
            // Second player's browser
            player1Tiles.forEach(tile => {
                tile.classList.remove('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player2Tiles.forEach(tile => {
                tile.classList.add('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player1Area.classList.remove('inactive');
            player2Area.classList.remove('active');
        }
    } else {
        if (socket.id === players.second) {
            // Second player's browser
            player2Tiles.forEach(tile => {
                tile.classList.remove('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player1Tiles.forEach(tile => {
                tile.classList.add('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player2Area.classList.add('active');
            player1Area.classList.add('inactive');
        } else {
            // First player's browser
            player2Tiles.forEach(tile => {
                tile.classList.remove('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player1Tiles.forEach(tile => {
                tile.classList.add('inactive');
                if (!tile.classList.contains('revealed')) {
                    tile.textContent = '';
                }
            });
            player2Area.classList.add('active');
            player1Area.classList.add('inactive');
        }
    }
}
function switchPlayer() {
    isMyTurn = !isMyTurn;
    currentPlayer = currentPlayer === 1 ? 2 : 1;
    updateTileColors();
}

function initGame() {
    setupOverlay.style.display = 'none';
    document.getElementById('gameBoard').style.display = 'flex';
    
    player1Area.innerHTML = '';
    player2Area.innerHTML = '';
    drawPile.innerHTML = '';
    
    createTiles(player1Area, 26);
    createTiles(player2Area, 26);
    createTiles(drawPile, 38, true); // Keep original 38 tiles
    
    updateTileColors();
    
    // Run initial cleanup after a short delay
    setTimeout(cleanupDuplicateTiles, 500);
}
// New functions for emoji code handling
function displayGameEmojis(emojis) {
    gameCodeEmojis.innerHTML = '';
    emojis.forEach(emoji => {
        const emojiElement = document.createElement('div');
        emojiElement.classList.add('emoji');
        emojiElement.textContent = emoji;
        
        // Add a little bounce animation
        emojiElement.animate([
            { transform: 'translateY(0)' },
            { transform: 'translateY(-10px)' },
            { transform: 'translateY(0)' }
        ], {
            duration: 1000,
            iterations: Infinity,
            easing: 'ease-in-out',
            delay: Math.random() * 500 // Stagger the animations
        });
        
        gameCodeEmojis.appendChild(emojiElement);
    });
}

function createEmojiGrid() {
    emojiGrid.innerHTML = '';
    
    // Shuffle the emojis for a random order each time
    const shuffledEmojis = [...emojis].sort(() => Math.random() - 0.5);
    
    shuffledEmojis.forEach(emoji => {
        const button = document.createElement('div');
        button.classList.add('emoji-button');
        button.textContent = emoji;
        button.addEventListener('click', () => {
            handleEmojiSelection(emoji, button);
        });
        emojiGrid.appendChild(button);
    });
    
    // Reset selection
    selectedEmojis = [];
    updateEmojiSelection();
}

function handleEmojiSelection(emoji, button) {
    // Check if already selected
    const index = selectedEmojis.indexOf(emoji);
    
    if (index > -1) {
        // Already selected, remove it
        selectedEmojis.splice(index, 1);
        button.classList.remove('selected');
    } else if (selectedEmojis.length < 3) {
        // Not selected and room for more, add it
        selectedEmojis.push(emoji);
        button.classList.add('selected');
    } else {
        // Not selected but already have 3, replace the first one
        const oldEmoji = selectedEmojis.shift();
        const oldButton = Array.from(emojiGrid.querySelectorAll('.emoji-button'))
            .find(btn => btn.textContent === oldEmoji);
        if (oldButton) oldButton.classList.remove('selected');
        
        selectedEmojis.push(emoji);
        button.classList.add('selected');
    }
    
    updateEmojiSelection();
}

function updateEmojiSelection() {
    // Update the slots to show current selection
    emojiSlots.forEach((slot, index) => {
        if (index < selectedEmojis.length) {
            slot.textContent = selectedEmojis[index];
        } else {
            slot.textContent = '';
        }
    });
}
</script>
</body>
</html>
